{% load static %}
<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SA</title>
    <link href="{% static 'style.css' %}" rel="stylesheet">
</head>

<body>
    <img src="{% static 'bg.jpg' %}" alt="" id="bg">
    <div class="container"><!-- only one container -->

        <!-- Form card -->
        <div class="card">
            <h1>SA</h1>
            <form id="configForm" method="post">
                <input type="hidden" name="algo" value="{{ algo }}">
                <div>
                    <label for="filename">Fichier de benchmark</label>
                    <!-- <input type="text" id="filename" name="filename" value="berlin52_coords.txt" /> -->
                    <select name="filename">
                        <option value="berlin52_coords.txt">Berlin52 Villes</option>
                        <option value="kr100_coords.txt">KR100</option>
                    </select>
                </div>
                <div>
                    <label for="INITIAL_TEMPERATURE">Temp√©rature initiale (INITIAL_TEMPERATURE)</label>
                    <input type="number" id="INITIAL_TEMPERATURE" name="INITIAL_TEMPERATURE" value="100.0" step="0.1"
                        min="0" />
                </div>

                <div>
                    <label for="COOLING_RATE">Taux de refroidissement (COOLING_RATE)</label>
                    <input type="number" id="COOLING_RATE" name="COOLING_RATE" value="0.995" step="0.001" min="0"
                        max="1" />
                </div>

                <div>
                    <label for="MAX_ITER">Nombre max d‚Äôit√©rations (MAX_ITER)</label>
                    <input type="number" id="MAX_ITER" name="MAX_ITER" value="300" step="1" min="1" />
                </div>

                <div>
                    <label for="RESTARTS">Nombre de red√©marrages (RESTARTS)</label>
                    <input type="number" id="RESTARTS" name="RESTARTS" value="3" step="1" min="1" />
                </div>

                <button type="submit">Lancer la r√©solution</button>
                <!-- <button type="button" id="compareButton">Comparer</button> -->
            </form>
        </div>

        <!-- Results card -->
        <div id="results" class="card hidden">
            <!-- Convergence & erreur charts -->
            <div>
                <h2>Convergence</h2>
                <canvas id="convergenceChart"></canvas>
            </div>
            <div>
                <h2>Erreur relative (%)</h2>
                <canvas id="errorChart"></canvas>
            </div>
            <pre id="logConsole"></pre>

            <!-- Meilleur tour (initialement cach√©) -->
            <div id="bestTour" class="full-width hidden">
                <h2>Meilleur tour</h2>
                <p id="bestTourText"></p>
            </div>

            <!-- Trace du tour (initialement cach√©e) -->
            <div id="pathContainer" class="full-width hidden">
                <h2>Trace du tour</h2>
                <canvas id="pathChart"></canvas>
            </div>
        </div>

    </div><!-- /container -->

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

    <script>
        // R√©cup√®re la valeur d‚Äôun cookie
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                document.cookie.split(';').forEach(cookie => {
                    const [key, val] = cookie.trim().split('=');
                    if (key === name) cookieValue = decodeURIComponent(val);
                });
            }
            return cookieValue;
        }
        const csrftoken = getCookie('csrftoken');

        document.addEventListener("DOMContentLoaded", () => {
            const form = document.getElementById("configForm");
            const compareButton = document.getElementById("compareButton");
            const results = document.getElementById("results");
            const logConsole = document.getElementById("logConsole");
            const bestTourEl = document.getElementById("bestTour");
            const bestTourText = document.getElementById("bestTourText");
            const pathContainer = document.getElementById("pathContainer");
            const pathCtx = document.getElementById("pathChart").getContext("2d");

            let pathChart;
            let distChart, errChart;
            let lastIt = 0;
            let pollInterval;

            // üü¢ RESET FUNCTION
            function restartAll() {
                results.classList.add("hidden");
                bestTourEl.classList.add("hidden");
                pathContainer.classList.add("hidden");
                logConsole.textContent = "";
                bestTourText.textContent = "";
                lastIt = 0;
                if (pollInterval) {
                    clearInterval(pollInterval);
                    pollInterval = null;
                }
                if (distChart) {
                    distChart.destroy();
                    distChart = null;
                }
                if (errChart) {
                    errChart.destroy();
                    errChart = null;
                }
                if (pathChart) {
                    pathChart.destroy();
                    pathChart = null;
                }
                document.getElementById("convergenceChart").getContext("2d").clearRect(0, 0, 400, 400);
                document.getElementById("errorChart").getContext("2d").clearRect(0, 0, 400, 400);
                document.getElementById("pathChart").getContext("2d").clearRect(0, 0, 400, 400);
            }

            // üü¢ On form submit
            form.addEventListener("submit", async (e) => {
                e.preventDefault();
                restartAll();

                // R√©cup√©ration des param√®tres
                const data = {};
                new FormData(form).forEach((value, key) => {
                    data[key] = isNaN(value) ? value : +value;
                });

                // D√©marrage du job
                const startRes = await fetch("{% url 'sa_app:run_sa' %}", {
                    method: "POST",
                    credentials: "same-origin",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": csrftoken
                    },
                    body: JSON.stringify(data)
                });

                if (!startRes.ok) {
                    console.error("√âchec d√©marrage job:", await startRes.text());
                    return;
                }

                // üîΩ R√©cup√©ration du job_id depuis la r√©ponse JSON
                const startData = await startRes.json();
                const job_id = startData.job_id;

                results.classList.remove("hidden");
                logConsole.textContent = "";
                lastIt = 0;

                // Initialisation des graphiques Chart.js
                const ctxD = document.getElementById("convergenceChart").getContext("2d");
                distChart = new Chart(ctxD, {
                    type: "line",
                    data: {
                        labels: [],
                        datasets: [{
                            label: "Distance",
                            data: [],
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            x: { title: { display: true, text: "Iteration" } },
                            y: { title: { display: true, text: "Distance" } }
                        }
                    }
                });

                const ctxE = document.getElementById("errorChart").getContext("2d");
                errChart = new Chart(ctxE, {
                    type: "line",
                    data: {
                        labels: [],
                        datasets: [{
                            label: "Erreur (%)",
                            data: [],
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            x: { title: { display: true, text: "Iteration" } },
                            y: { title: { display: true, text: "Erreur (%)" } }
                        }
                    }
                });

                // Lancement du polling avec le job_id
                pollInterval = setInterval(async () => {
                    // üîΩ Ajout du job_id dans la requ√™te GET
                    const statusRes = await fetch(`{% url 'sa_app:result' %}?job_id=${encodeURIComponent(job_id)}`, {
                        credentials: "same-origin"
                    });

                    const job = await statusRes.json();
                    console.log("üîÑ Status du job :", job);

                    if (job.logs && job.logs.length > lastIt) {
                        const newLogs = job.logs.slice(lastIt);
                        newLogs.forEach(entry => {
                            console.log(`üìà It ${entry.iteration}`, entry);
                            distChart.data.labels.push(entry.iteration);
                            distChart.data.datasets[0].data.push(entry.distance);
                            errChart.data.labels.push(entry.iteration);
                            errChart.data.datasets[0].data.push(entry.error);
                            logConsole.textContent +=
                                `It ${entry.iteration} | Dist: ${entry.distance} | Err: ${entry.error}% | Temps: ${entry.temps}s\n`;
                        });
                        distChart.update();
                        errChart.update();
                        lastIt = job.logs.length;
                    }

                    if (job.status === "done" || job.status === "error") {
                        clearInterval(pollInterval);


                        if (job.status === "done") {
                            bestTourEl.classList.remove("hidden");
                            bestTourText.textContent = job.tour.join(" ‚Üí ");

                            const tourCoords = job.tour.map(idx => ({
                                x: job.city_coords[idx][0],
                                y: job.city_coords[idx][1]
                            }));
                            tourCoords.push(tourCoords[0]);
                            const startPoint = [tourCoords[0]];
                            pathContainer.classList.remove("hidden");

                            if (!pathChart) {
                                pathChart = new Chart(pathCtx, {
                                    type: "scatter",
                                    data: {
                                        datasets: [
                                            {
                                                label: "Tour",
                                                data: tourCoords,
                                                showLine: true,
                                                fill: false,
                                                borderColor: "#2563eb",
                                                pointRadius: 4,
                                                pointBackgroundColor: "#2563eb"
                                            },
                                            {
                                                label: "D√©part",
                                                data: startPoint,
                                                showLine: false,
                                                pointRadius: 8,
                                                pointBackgroundColor: "red"
                                            }
                                        ]
                                    },
                                    options: {
                                        responsive: true,
                                        scales: {
                                            x: { type: "linear", title: { display: true, text: "X" } },
                                            y: { type: "linear", title: { display: true, text: "Y" } }
                                        }
                                    }
                                });
                            } else {
                                pathChart.data.datasets[0].data = tourCoords;
                                pathChart.update();
                            }
                            console.log("üñºÔ∏è pathChart instance:", pathChart);
                            console.log("‚úÖ Affichage du chemin, pathContainer classes:", pathContainer.classList);
                            logConsole.textContent += "\n‚úÖ Ex√©cution termin√©e\n";

                            return;
                        }

                        if (job.status === "error") {
                            logConsole.textContent += `\nErreur serveur : ${job.error_msg}\n`;
                        }
                    }
                }, 250);
            });

            // üü¢ Compare button reset
            compareButton.addEventListener("click", () => {
                restartAll();
                // Ajoutez ici la logique de comparaison si besoin
            });

        });

    </script>

</body>


</html>